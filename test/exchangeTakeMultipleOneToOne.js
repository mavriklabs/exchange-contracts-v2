const { expect } = require("chai");
const { ethers, network } = require("hardhat");
const { deployContract, nowSeconds, NULL_ADDRESS } = require("../tasks/utils");
const {
  prepareOBOrder,
  getCurrentSignedOrderPrice,
  signFormattedOrder,
  approveERC721
} = require("../helpers/orders");
const { erc721Abi } = require("../abi/erc721");

describe("Exchange_Take_Multiple_One_To_One", function () {
  let signers,
    signer1,
    signer2,
    signer3,
    token,
    flowExchange,
    mock721Contract1,
    mock721Contract2,
    mock721Contract3,
    obComplication;

  const sellOrders = [];

  let signer1EthBalance = 0;
  let signer2EthBalance = 0;
  let totalProtocolFees = toBN(0);
  let orderNonce = 0;
  let numTakeSellOrders = -1;

  const FEE_BPS = 250;
  const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
  const UNIT = toBN(1e18);
  const INITIAL_SUPPLY = toBN(1_000_000).mul(UNIT);

  const totalNFTSupply = 100;
  const numNFTsToTransfer = 50;
  const numNFTsLeft = totalNFTSupply - numNFTsToTransfer;

  function toBN(val) {
    return ethers.BigNumber.from(val.toString());
  }

  before(async () => {
    // reset state
    await network.provider.request({
      method: "hardhat_reset",
      params: []
    });

    // signers
    signers = await ethers.getSigners();
    signer1 = signers[0];
    signer2 = signers[1];
    signer3 = signers[2];
    // token
    token = await deployContract(
      "MockERC20",
      await ethers.getContractFactory("MockERC20"),
      signers[0]
    );

    // NFT contracts
    mock721Contract1 = await deployContract(
      "MockERC721",
      await ethers.getContractFactory("MockERC721"),
      signer1,
      ["Mock NFT 1", "MCKNFT1"]
    );
    mock721Contract2 = await deployContract(
      "MockERC721",
      await ethers.getContractFactory("MockERC721"),
      signer1,
      ["Mock NFT 2", "MCKNFT2"]
    );
    mock721Contract3 = await deployContract(
      "MockERC721",
      await ethers.getContractFactory("MockERC721"),
      signer1,
      ["Mock NFT 3", "MCKNFT3"]
    );

    // Exchange
    flowExchange = await deployContract(
      "FlowExchange",
      await ethers.getContractFactory("FlowExchange"),
      signer1,
      [token.address, signer3.address]
    );

    // OB complication
    obComplication = await deployContract(
      "FlowOrderBookComplication",
      await ethers.getContractFactory("FlowOrderBookComplication"),
      signer1,
      [token.address]
    );

    // add currencies to registry
    // await flowExchange.addCurrency(token.address);
    // await flowExchange.addCurrency(NULL_ADDRESS);
    await obComplication.addCurrency(token.address);

    // add complications to registry
    // await flowExchange.addCurrency(token.address);

    // send assets
    await token.transfer(signer2.address, INITIAL_SUPPLY.div(2).toString());
    for (let i = 0; i < numNFTsToTransfer; i++) {
      await mock721Contract1.transferFrom(signer1.address, signer2.address, i);
      await mock721Contract2.transferFrom(signer1.address, signer2.address, i);
      await mock721Contract3.transferFrom(signer1.address, signer2.address, i);
    }
  });

  describe("Setup", () => {
    it("Should init properly", async function () {
      expect(await token.decimals()).to.equal(18);
      expect(await token.totalSupply()).to.equal(INITIAL_SUPPLY);

      expect(await token.balanceOf(signer1.address)).to.equal(INITIAL_SUPPLY.div(2));
      expect(await token.balanceOf(signer2.address)).to.equal(INITIAL_SUPPLY.div(2));

      expect(await mock721Contract1.balanceOf(signer1.address)).to.equal(numNFTsLeft);
      expect(await mock721Contract1.balanceOf(signer2.address)).to.equal(numNFTsToTransfer);

      expect(await mock721Contract2.balanceOf(signer1.address)).to.equal(numNFTsLeft);
      expect(await mock721Contract2.balanceOf(signer2.address)).to.equal(numNFTsToTransfer);

      expect(await mock721Contract3.balanceOf(signer1.address)).to.equal(numNFTsLeft);
      expect(await mock721Contract3.balanceOf(signer2.address)).to.equal(numNFTsToTransfer);
    });
  });

  // ================================================== MAKE SELL ORDERS ==================================================

  // one specific collection, one specific token, min price
  describe("OneCollectionOneTokenSell1", () => {
    it("Signed order should be valid", async function () {
      const user = {
        address: signer2.address
      };
      const chainId = network.config.chainId ?? 31337;
      const nfts = [
        {
          collection: mock721Contract1.address,
          tokens: [{ tokenId: 0, numTokens: 1 }]
        }
      ];
      const execParams = {
        complicationAddress: obComplication.address,
        currencyAddress: ZERO_ADDRESS
      };
      const extraParams = {};
      const nonce = ++orderNonce;
      const orderId = ethers.utils.solidityKeccak256(
        ["address", "uint256", "uint256"],
        [user.address, nonce, chainId]
      );
      let numItems = 0;
      for (const nft of nfts) {
        numItems += nft.tokens.length;
      }
      const order = {
        id: orderId,
        chainId,
        isSellOrder: true,
        signerAddress: user.address,
        numItems,
        startPrice: ethers.utils.parseEther("1"),
        endPrice: ethers.utils.parseEther("1"),
        startTime: nowSeconds(),
        endTime: nowSeconds().add(10 * 60),
        nonce,
        nfts,
        execParams,
        extraParams
      };
      const signedOrder = await prepareOBOrder(
        user,
        chainId,
        signer2,
        order,
        flowExchange,
        obComplication
      );
      expect(signedOrder).to.not.be.undefined;
      sellOrders.push(signedOrder);
    });
  });

  describe("OneCollectionOneTokenSell2", () => {
    it("Signed order should be valid", async function () {
      const user = {
        address: signer2.address
      };
      const chainId = network.config.chainId ?? 31337;
      const nfts = [
        {
          collection: mock721Contract1.address,
          tokens: [{ tokenId: 1, numTokens: 1 }]
        }
      ];
      const execParams = {
        complicationAddress: obComplication.address,
        currencyAddress: ZERO_ADDRESS
      };
      const extraParams = {};
      const nonce = ++orderNonce;
      const orderId = ethers.utils.solidityKeccak256(
        ["address", "uint256", "uint256"],
        [user.address, nonce, chainId]
      );
      let numItems = 0;
      for (const nft of nfts) {
        numItems += nft.tokens.length;
      }
      const order = {
        id: orderId,
        chainId,
        isSellOrder: true,
        signerAddress: user.address,
        numItems,
        startPrice: ethers.utils.parseEther("1"),
        endPrice: ethers.utils.parseEther("1"),
        startTime: nowSeconds(),
        endTime: nowSeconds().add(10 * 60),
        nonce,
        nfts,
        execParams,
        extraParams
      };
      const signedOrder = await prepareOBOrder(
        user,
        chainId,
        signer2,
        order,
        flowExchange,
        obComplication
      );
      expect(signedOrder).to.not.be.undefined;
      sellOrders.push(signedOrder);
    });
  });

  describe("OneCollectionOneTokenSell3", () => {
    it("Signed order should be valid", async function () {
      const user = {
        address: signer2.address
      };
      const chainId = network.config.chainId ?? 31337;
      const nfts = [
        {
          collection: mock721Contract1.address,
          tokens: [{ tokenId: 2, numTokens: 1 }]
        }
      ];
      const execParams = {
        complicationAddress: obComplication.address,
        currencyAddress: ZERO_ADDRESS
      };
      const extraParams = {};
      const nonce = ++orderNonce;
      const orderId = ethers.utils.solidityKeccak256(
        ["address", "uint256", "uint256"],
        [user.address, nonce, chainId]
      );
      let numItems = 0;
      for (const nft of nfts) {
        numItems += nft.tokens.length;
      }
      const order = {
        id: orderId,
        chainId,
        isSellOrder: true,
        signerAddress: user.address,
        numItems,
        startPrice: ethers.utils.parseEther("1"),
        endPrice: ethers.utils.parseEther("1"),
        startTime: nowSeconds(),
        endTime: nowSeconds().add(10 * 60),
        nonce,
        nfts,
        execParams,
        extraParams
      };
      const signedOrder = await prepareOBOrder(
        user,
        chainId,
        signer2,
        order,
        flowExchange,
        obComplication
      );
      expect(signedOrder).to.not.be.undefined;
      sellOrders.push(signedOrder);
    });
  });

  describe("OneCollectionOneTokenSell4", () => {
    it("Signed order should be valid", async function () {
      const user = {
        address: signer2.address
      };
      const chainId = network.config.chainId ?? 31337;
      const nfts = [
        {
          collection: mock721Contract1.address,
          tokens: [{ tokenId: 3, numTokens: 1 }]
        }
      ];
      const execParams = {
        complicationAddress: obComplication.address,
        currencyAddress: ZERO_ADDRESS
      };
      const extraParams = {};
      const nonce = ++orderNonce;
      const orderId = ethers.utils.solidityKeccak256(
        ["address", "uint256", "uint256"],
        [user.address, nonce, chainId]
      );
      let numItems = 0;
      for (const nft of nfts) {
        numItems += nft.tokens.length;
      }
      const order = {
        id: orderId,
        chainId,
        isSellOrder: true,
        signerAddress: user.address,
        numItems,
        startPrice: ethers.utils.parseEther("1"),
        endPrice: ethers.utils.parseEther("1"),
        startTime: nowSeconds(),
        endTime: nowSeconds().add(10 * 60),
        nonce,
        nfts,
        execParams,
        extraParams
      };
      const signedOrder = await prepareOBOrder(
        user,
        chainId,
        signer2,
        order,
        flowExchange,
        obComplication
      );
      expect(signedOrder).to.not.be.undefined;
      sellOrders.push(signedOrder);
    });
  });

  describe("OneCollectionOneTokenSell5", () => {
    it("Signed order should be valid", async function () {
      const user = {
        address: signer2.address
      };
      const chainId = network.config.chainId ?? 31337;
      const nfts = [
        {
          collection: mock721Contract1.address,
          tokens: [{ tokenId: 4, numTokens: 1 }]
        }
      ];
      const execParams = {
        complicationAddress: obComplication.address,
        currencyAddress: ZERO_ADDRESS
      };
      const extraParams = {};
      const nonce = ++orderNonce;
      const orderId = ethers.utils.solidityKeccak256(
        ["address", "uint256", "uint256"],
        [user.address, nonce, chainId]
      );
      let numItems = 0;
      for (const nft of nfts) {
        numItems += nft.tokens.length;
      }
      const order = {
        id: orderId,
        chainId,
        isSellOrder: true,
        signerAddress: user.address,
        numItems,
        startPrice: ethers.utils.parseEther("1"),
        endPrice: ethers.utils.parseEther("1"),
        startTime: nowSeconds(),
        endTime: nowSeconds().add(10 * 60),
        nonce,
        nfts,
        execParams,
        extraParams
      };
      const signedOrder = await prepareOBOrder(
        user,
        chainId,
        signer2,
        order,
        flowExchange,
        obComplication
      );
      expect(signedOrder).to.not.be.undefined;
      sellOrders.push(signedOrder);
    });
  });

  describe("OneCollectionOneTokenSell6", () => {
    it("Signed order should be valid", async function () {
      const user = {
        address: signer2.address
      };
      const chainId = network.config.chainId ?? 31337;
      const nfts = [
        {
          collection: mock721Contract1.address,
          tokens: [{ tokenId: 5, numTokens: 1 }]
        }
      ];
      const execParams = {
        complicationAddress: obComplication.address,
        currencyAddress: ZERO_ADDRESS
      };
      const extraParams = {};
      const nonce = ++orderNonce;
      const orderId = ethers.utils.solidityKeccak256(
        ["address", "uint256", "uint256"],
        [user.address, nonce, chainId]
      );
      let numItems = 0;
      for (const nft of nfts) {
        numItems += nft.tokens.length;
      }
      const order = {
        id: orderId,
        chainId,
        isSellOrder: true,
        signerAddress: user.address,
        numItems,
        startPrice: ethers.utils.parseEther("1"),
        endPrice: ethers.utils.parseEther("1"),
        startTime: nowSeconds(),
        endTime: nowSeconds().add(10 * 60),
        nonce,
        nfts,
        execParams,
        extraParams
      };
      const signedOrder = await prepareOBOrder(
        user,
        chainId,
        signer2,
        order,
        flowExchange,
        obComplication
      );
      expect(signedOrder).to.not.be.undefined;
      sellOrders.push(signedOrder);
    });
  });

  describe("OneCollectionOneTokenSell7", () => {
    it("Signed order should be valid", async function () {
      const user = {
        address: signer2.address
      };
      const chainId = network.config.chainId ?? 31337;
      const nfts = [
        {
          collection: mock721Contract1.address,
          tokens: [{ tokenId: 6, numTokens: 1 }]
        }
      ];
      const execParams = {
        complicationAddress: obComplication.address,
        currencyAddress: ZERO_ADDRESS
      };
      const extraParams = {};
      const nonce = ++orderNonce;
      const orderId = ethers.utils.solidityKeccak256(
        ["address", "uint256", "uint256"],
        [user.address, nonce, chainId]
      );
      let numItems = 0;
      for (const nft of nfts) {
        numItems += nft.tokens.length;
      }
      const order = {
        id: orderId,
        chainId,
        isSellOrder: true,
        signerAddress: user.address,
        numItems,
        startPrice: ethers.utils.parseEther("1"),
        endPrice: ethers.utils.parseEther("1"),
        startTime: nowSeconds(),
        endTime: nowSeconds().add(10 * 60),
        nonce,
        nfts,
        execParams,
        extraParams
      };
      const signedOrder = await prepareOBOrder(
        user,
        chainId,
        signer2,
        order,
        flowExchange,
        obComplication
      );
      expect(signedOrder).to.not.be.undefined;
      sellOrders.push(signedOrder);
    });
  });

  describe("OneCollectionOneTokenSell8", () => {
    it("Signed order should be valid", async function () {
      const user = {
        address: signer2.address
      };
      const chainId = network.config.chainId ?? 31337;
      const nfts = [
        {
          collection: mock721Contract1.address,
          tokens: [{ tokenId: 7, numTokens: 1 }]
        }
      ];
      const execParams = {
        complicationAddress: obComplication.address,
        currencyAddress: ZERO_ADDRESS
      };
      const extraParams = {};
      const nonce = ++orderNonce;
      const orderId = ethers.utils.solidityKeccak256(
        ["address", "uint256", "uint256"],
        [user.address, nonce, chainId]
      );
      let numItems = 0;
      for (const nft of nfts) {
        numItems += nft.tokens.length;
      }
      const order = {
        id: orderId,
        chainId,
        isSellOrder: true,
        signerAddress: user.address,
        numItems,
        startPrice: ethers.utils.parseEther("1"),
        endPrice: ethers.utils.parseEther("1"),
        startTime: nowSeconds(),
        endTime: nowSeconds().add(10 * 60),
        nonce,
        nfts,
        execParams,
        extraParams
      };
      const signedOrder = await prepareOBOrder(
        user,
        chainId,
        signer2,
        order,
        flowExchange,
        obComplication
      );
      expect(signedOrder).to.not.be.undefined;
      sellOrders.push(signedOrder);
    });
  });

  describe("OneCollectionOneTokenSell9", () => {
    it("Signed order should be valid", async function () {
      const user = {
        address: signer2.address
      };
      const chainId = network.config.chainId ?? 31337;
      const nfts = [
        {
          collection: mock721Contract1.address,
          tokens: [{ tokenId: 8, numTokens: 1 }]
        }
      ];
      const execParams = {
        complicationAddress: obComplication.address,
        currencyAddress: ZERO_ADDRESS
      };
      const extraParams = {};
      const nonce = ++orderNonce;
      const orderId = ethers.utils.solidityKeccak256(
        ["address", "uint256", "uint256"],
        [user.address, nonce, chainId]
      );
      let numItems = 0;
      for (const nft of nfts) {
        numItems += nft.tokens.length;
      }
      const order = {
        id: orderId,
        chainId,
        isSellOrder: true,
        signerAddress: user.address,
        numItems,
        startPrice: ethers.utils.parseEther("1"),
        endPrice: ethers.utils.parseEther("1"),
        startTime: nowSeconds(),
        endTime: nowSeconds().add(10 * 60),
        nonce,
        nfts,
        execParams,
        extraParams
      };
      const signedOrder = await prepareOBOrder(
        user,
        chainId,
        signer2,
        order,
        flowExchange,
        obComplication
      );
      expect(signedOrder).to.not.be.undefined;
      sellOrders.push(signedOrder);
    });
  });

  describe("OneCollectionOneTokenSell10", () => {
    it("Signed order should be valid", async function () {
      const user = {
        address: signer2.address
      };
      const chainId = network.config.chainId ?? 31337;
      const nfts = [
        {
          collection: mock721Contract1.address,
          tokens: [{ tokenId: 9, numTokens: 1 }]
        }
      ];
      const execParams = {
        complicationAddress: obComplication.address,
        currencyAddress: ZERO_ADDRESS
      };
      const extraParams = {};
      const nonce = ++orderNonce;
      const orderId = ethers.utils.solidityKeccak256(
        ["address", "uint256", "uint256"],
        [user.address, nonce, chainId]
      );
      let numItems = 0;
      for (const nft of nfts) {
        numItems += nft.tokens.length;
      }
      const order = {
        id: orderId,
        chainId,
        isSellOrder: true,
        signerAddress: user.address,
        numItems,
        startPrice: ethers.utils.parseEther("1"),
        endPrice: ethers.utils.parseEther("1"),
        startTime: nowSeconds(),
        endTime: nowSeconds().add(10 * 60),
        nonce,
        nfts,
        execParams,
        extraParams
      };
      const signedOrder = await prepareOBOrder(
        user,
        chainId,
        signer2,
        order,
        flowExchange,
        obComplication
      );
      expect(signedOrder).to.not.be.undefined;
      sellOrders.push(signedOrder);
    });
  });

  // ================================================== TAKE SELL ORDERS ===================================================

  describe("Take_OneCollectionOneTokenSell", () => {
    it("Should take valid order", async function () {
      // order 1
      const sellOrder1 = sellOrders[++numTakeSellOrders];
      const nfts1 = sellOrder1.nfts;
      const salePrice1 = getCurrentSignedOrderPrice(sellOrder1);
      // owners before sale
      for (const item of nfts1) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer2.address);
        }
      }

      // order 2
      const sellOrder2 = sellOrders[++numTakeSellOrders];
      const nfts2 = sellOrder2.nfts;
      const salePrice2 = getCurrentSignedOrderPrice(sellOrder2);
      // owners before sale
      for (const item of nfts2) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer2.address);
        }
      }

      // order 3
      const sellOrder3 = sellOrders[++numTakeSellOrders];
      const nfts3 = sellOrder3.nfts;
      const salePrice3 = getCurrentSignedOrderPrice(sellOrder3);
      // owners before sale
      for (const item of nfts3) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer2.address);
        }
      }

      // order 4
      const sellOrder4 = sellOrders[++numTakeSellOrders];
      const nfts4 = sellOrder4.nfts;
      const salePrice4 = getCurrentSignedOrderPrice(sellOrder4);
      // owners before sale
      for (const item of nfts4) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer2.address);
        }
      }

      // order 5
      const sellOrder5 = sellOrders[++numTakeSellOrders];
      const nfts5 = sellOrder5.nfts;
      const salePrice5 = getCurrentSignedOrderPrice(sellOrder5);
      // owners before sale
      for (const item of nfts5) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer2.address);
        }
      }

      // order 6
      const sellOrder6 = sellOrders[++numTakeSellOrders];
      const nfts6 = sellOrder6.nfts;
      const salePrice6 = getCurrentSignedOrderPrice(sellOrder6);
      // owners before sale
      for (const item of nfts6) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer2.address);
        }
      }

      // order 7
      const sellOrder7 = sellOrders[++numTakeSellOrders];
      const nfts7 = sellOrder7.nfts;
      const salePrice7 = getCurrentSignedOrderPrice(sellOrder7);
      // owners before sale
      for (const item of nfts7) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer2.address);
        }
      }

      // order 8
      const sellOrder8 = sellOrders[++numTakeSellOrders];
      const nfts8 = sellOrder8.nfts;
      const salePrice8 = getCurrentSignedOrderPrice(sellOrder8);
      // owners before sale
      for (const item of nfts8) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer2.address);
        }
      }

      // order 9
      const sellOrder9 = sellOrders[++numTakeSellOrders];
      const nfts9 = sellOrder5.nfts;
      const salePrice9 = getCurrentSignedOrderPrice(sellOrder9);
      // owners before sale
      for (const item of nfts9) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer2.address);
        }
      }

      // order 10
      const sellOrder10 = sellOrders[++numTakeSellOrders];
      const nfts10 = sellOrder10.nfts;
      const salePrice10 = getCurrentSignedOrderPrice(sellOrder10);
      // owners before sale
      for (const item of nfts10) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer2.address);
        }
      }

      // balance before sale
      signer1EthBalance = parseFloat(
        ethers.utils.formatEther(await ethers.provider.getBalance(signer1.address))
      );
      signer2EthBalance = parseFloat(
        ethers.utils.formatEther(await ethers.provider.getBalance(signer2.address))
      );

      // perform exchange
      const salePrice = salePrice1
        .add(salePrice2)
        .add(salePrice3)
        .add(salePrice4)
        .add(salePrice5)
        .add(salePrice6)
        .add(salePrice7)
        .add(salePrice8)
        .add(salePrice9)
        .add(salePrice10);
      const salePriceInEth = parseFloat(ethers.utils.formatEther(salePrice));
      const options = {
        value: salePrice
      };
      // estimate gas
      const orders = [
        sellOrder1,
        sellOrder2,
        sellOrder3,
        sellOrder4,
        sellOrder5,
        sellOrder6,
        sellOrder7,
        sellOrder8,
        sellOrder9,
        sellOrder10
      ];
      const numOrders = orders.length;
      const gasEstimate = await flowExchange
        .connect(signer1)
        .estimateGas.takeMultipleOneOrders(orders, options);
      console.log("gasEstimate", gasEstimate.toNumber());
      console.log("num tokens", orders.length);
      console.log("gasEstimate per order", gasEstimate.div(numOrders).toNumber());

      await flowExchange.connect(signer1).takeMultipleOneOrders(orders, options);

      // owners after sale
      for (const item of nfts1) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer1.address);
        }
      }
      for (const item of nfts2) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer1.address);
        }
      }
      for (const item of nfts3) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer1.address);
        }
      }
      for (const item of nfts4) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer1.address);
        }
      }
      for (const item of nfts5) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer1.address);
        }
      }
      for (const item of nfts6) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer1.address);
        }
      }
      for (const item of nfts7) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer1.address);
        }
      }
      for (const item of nfts8) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer1.address);
        }
      }
      for (const item of nfts9) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer1.address);
        }
      }
      for (const item of nfts10) {
        const collection = item.collection;
        const contract = new ethers.Contract(collection, erc721Abi, signer1);
        for (const token of item.tokens) {
          const tokenId = token.tokenId;
          expect(await contract.ownerOf(tokenId)).to.equal(signer1.address);
        }
      }

      // balance after sale
      const fee = salePrice.mul(FEE_BPS).div(10000);
      const feeInEth = parseFloat(ethers.utils.formatEther(fee));
      totalProtocolFees = totalProtocolFees.add(fee);
      expect(await ethers.provider.getBalance(flowExchange.address)).to.equal(totalProtocolFees);
      signer1EthBalance = signer1EthBalance - salePriceInEth;
      signer2EthBalance = signer2EthBalance + (salePriceInEth - feeInEth);
      const signer1EthBalanceAfter = parseFloat(
        ethers.utils.formatEther(await ethers.provider.getBalance(signer1.address))
      );
      const signer2EthBalanceAfter = parseFloat(
        ethers.utils.formatEther(await ethers.provider.getBalance(signer2.address))
      );
      expect(signer1EthBalanceAfter).to.be.lessThan(signer1EthBalance); // to account for gas
      // expect(signer2EthBalanceAfter).to.equal(signer2EthBalance);
    });
  });
});
